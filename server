#!/usr/bin/env python3

import socketserver
import http.server
import http.client
import email.utils
import collections
import threading
import functools
import argparse
import hashlib
import random
import json
import time
import sys
import os


# O servidor. Contém o recurso raíz, e um método para encontrar recursos a
# partir daquele.
class Server(socketserver.ThreadingMixIn, http.server.HTTPServer):

    # Construtor. Cria um recurso raíz e um recurso simbolizando "não
    # encontrado".
    def __init__(self, address, port):
        socketserver.ThreadingMixIn.__init__(self)
        http.server.HTTPServer.__init__(self, (address, port), Handler)
        self.root = Resource()
        self.not_found = Resource({'code': http.client.NOT_FOUND})

    # Método para encontrar um recurso dado um caminho, separado por '/'.
    # Se não encontrá-lo, devolve o recurso "não encontrado". Por exemplo, para
    # encontrar o recurso /game/abc123, procura-se o recurso "game" no recurso
    # raíz, e nele o recurso "abc123".
    def find_resource(self, path):
        path_list = path.split('/')
        path_list.pop(0)

        res = self.root
        for name in path_list:
            if name not in res.children:
                return self.not_found
            res = res.children[name]
        return res


# Esta classe é instanciada para cada requisição feita ao servidor, e é
# responsável por ler os dados de entrada, tratá-los e enviar a resposta.
# Neste programa, cada recurso é responsável por tratar requisições feitas a si
# mesmo, então o tratamento consiste em chamar o método correspondente no
# recurso e enviar como resposta o retorno.
class Handler(http.server.BaseHTTPRequestHandler):

    # Trata uma requisição GET.
    def do_GET(self):
        self.reply(self.server.find_resource(self.path).do_GET(self.read()))

    # Trata uma requisição POST.
    def do_POST(self):
        self.reply(self.server.find_resource(self.path).do_POST(self.read()))

    # Trata uma requisição PUT.
    def do_PUT(self):
        self.reply(self.server.find_resource(self.path).do_PUT(self.read()))

    # Lê o corpo da mensagem formatado como JSON e devolve um dicionário
    # correspondente. Adiciona um campo timestamp correspondente à última
    # atualização do cliente. Recursos podem ou não fazer uso dele.
    def read(self):
        data = {}
        length = self.read_length()
        timestamp = self.read_timestamp()
        try:
            text = self.rfile.read(length).decode('utf-8')
            data = json.loads(text)
        except:
            pass
        finally:
            data.update({'timestamp': timestamp})
            return data

    # Lê o tamanho da mensagem no cabeçalho. Se não presente, assume 0.
    def read_length(self):
        h = 'Content-Length'
        return int(self.headers[h]) if h in self.headers else 0

    # Obtém o timestamp da requisição. Pode estar no cabeçalho, mas se não
    # estiver, usa a menor data possível para indicar que o cliente não tem
    # nenhum dado.
    def read_timestamp(self):
        field = 'If-Modified-Since'
        if field not in self.headers:
            return time.mktime(time.gmtime(0))
        return time.mktime(email.utils.parsedate((self.headers[field])))

    # Responde a requisição com um código de status, campos de cabeçalho e
    # corpo da mensagem, todos opcionais. O corpo da mensagem deve ser um
    # dicionário, a ser formatado como JSON para transmissão.
    def reply(self, args={}):
        response = {'code': http.client.OK, 'data': None, 'headers': []}
        response.update(args)

        code = response['code']
        headers = response['headers'] + [('Content-Type', 'text/json')]
        text = json.dumps(response['data'])

        try:
            self.send_response(code)

            for h in headers:
                self.send_header(h[0], h[1])
            self.end_headers()

            self.wfile.write(bytes(text, 'utf-8'))
        except:
            pass


# Classe abstrata. Cada recurso tem um dicionário de recursos filhos, mapeados
# por um nome, ou caminho relativo. Sabem responder requisições feitas a ele.
# Tipicamente, uma requisição GET retorna os dados do recurso, POST cria um
# recurso filho nele, e PUT atualiza os dados.
class Resource:

    # Construtor. Define o código de retorno padrão como "método não
    # permitido". É esperado que subclasses sobrescrevam este comportamento.
    def __init__(self, default_reply={'code': http.client.METHOD_NOT_ALLOWED}):
        self.children = {}
        self.on_delete = None
        self.on_add_sibling = None
        self.default_reply = default_reply

    # Adiciona um recurso filho dado um nome do recurso, que é o caminho
    # relativo ao caminho deste recurso. Também faz com que, ao chamar o método
    # delete(), chame o método delete_child() deste objeto.
    def add_child(self, name, resource):
        self.children[name] = resource
        resource.on_delete = functools.partial(self.delete_child, name)
        resource.on_add_sibling = self.add_child

    # Delete um recurso filho.
    def delete_child(self, name):
        self.children.pop(name)

    # Adiciona um recurso irmão, chamando a função on_add_sibling, geralmente
    # setada pelo recurso pai no método add_child().
    def add_sibling(self, name, resource):
        if self.on_add_sibling:
            self.on_add_sibling(name, resource)

    # Deleta este recurso. Se tiver sido adicionado a um recurso pai através de
    # add_child(), chamará o método dele para remover este recurso.
    def delete(self):
        if self.on_delete:
            self.on_delete()

    # Trata uma requisição GET.
    def do_GET(self, data):
        return self.default_reply

    # Trata uma requisição POST.
    def do_POST(self, data):
        return self.default_reply

    # Trata uma requisição PUT.
    def do_PUT(self, data):
        return self.default_reply


# Classe abstrata que monitora sua data de atualização. Requisições GET de
# clientes que já tenham o recurso atualizado serão bloqueadas até que o evento
# sinalizando atualização seja disparado.
class Monitor(Resource):

    # Construtor. Define a última data de atualização como "agora".
    def __init__(self):
        Resource.__init__(self)
        self.timestamp = time.time()
        self.update_event = threading.Event()

    # Trata uma requisição GET, bloqueando se for necessário. Após a liberação,
    # retorna os dados do recurso.
    def do_GET(self, data):
        if data['timestamp'] >= self.timestamp:
            self.update_event.wait()
        return {'data': self.get_data(),
                'headers': [('Last-Modified',
                             email.utils.formatdate(self.timestamp))]}

    # Atualiza o timestamp e dispara o evento sinalizando atualização.
    def notify(self):
        self.timestamp = time.time()
        self.update_event.set()
        self.update_event.clear()

    # Método abstrato que obtém os dados do recurso.
    def get_data(self):
        return None


# Recurso cujos dados são os recursos filhos, e os monitora por adições e
# remoções.
class Container(Monitor):

    # Implementado da superclasse. Retorna uma lista do caminho relativo de
    # cada recurso filho.
    def get_data(self):
        return [name for name in self.children.copy()]

    # Ao adicionar um recurso filho, notifica por atualizações.
    def add_child(self, path, resource):
        Resource.add_child(self, path, resource)
        self.notify()

    # Ao remover um recurso filho, notifica por atualizações.
    def delete_child(self, path):
        Resource.delete_child(self, path)
        self.notify()


# O jogo é um container cujo recursos filhos monitorados são os jogadores.
# Adicionalmente, executa sua lógica a cada intervalo de tempo.
class Game(Container, threading.Thread):

    # Construtor. Recebe o intervalo de tempo entre cada execução da lógica.
    def __init__(self, time_step):
        threading.Thread.__init__(self)
        Container.__init__(self)
        self.time_step = time_step

    # Cria um recurso filho (um jogador), validando dados de entrada. Como o
    # conjunto de jogadores foi alterado, dispara notificação ao final.
    def do_POST(self, data):
        if 'password' not in data:
            return {'code': http.client.EXPECTATION_FAILED}

        accepted = ['name']

        attributes={k: v for k, v in data.items() if k in accepted}
        password = data['password']

        p = Player(attributes, password)

        token = hashlib.md5(os.urandom(4096)).hexdigest()
        self.add_child(token, p)

        self.notify()
        return {'code': http.client.CREATED,
                'headers': [('Location', token)]}

    # Sobrescrito de Thread. Executa a lógica do jogo e envia notificações em
    # seguida, repetidamente. Trata colisões.
    def run(self):
        while True:
            time.sleep(self.time_step)

            occupied = self.get_occupied()
            for p in self.children.values():
                oldx, oldy = p.attributes['posx'], p.attributes['posy']
                x, y = oldx + p.attributes['movx'], oldy + p.attributes['movy']
                if x == oldx and y == oldy:
                    continue

                if x in occupied and y in occupied[x]:
                    p.collide(occupied[x][y])
                    occupied[x][y].collide(p)
                else:
                    occupied[x][y] = p
                    p.update({'posx': x, 'posy': y})

    # Retorna um dicionário que mapeia para cada X um dicionário. Este mapeia,
    # para cada Y, um jogador. Substitui uma matriz.
    def get_occupied(self):
        d = collections.defaultdict(dict)
        d.update({p.attributes['posx']: {p.attributes['posy']: p}
                  for p in self.children.values()})
        return d


# Um jogador monitora seu estado, que é um conjunto de atributos.
class Player(Monitor):

    # Construtor. Recebe uma senha para modificações.
    def __init__(self, data, password):
        Monitor.__init__(self)
        self.password = password
        self.attributes = data
        self.update({'hp': 10, 'kills': 0,
            'posx': random.randrange(0, 10), 'posy': random.randrange(0, 10),
            'movx': 0, 'movy': 0, 'comx': 0, 'comy': 0})

    # Implementado da superclasse. Uma requisição GET retorna os atributos do
    # jogador.
    def get_data(self):
        return self.attributes

    # Valida dados de entrada e chama atualização. Aceita apenas modificações
    # em movement e combat.
    def do_PUT(self, data):
        if 'password' not in data:
            return {'code': http.client.EXPECTATION_FAILED}
        if data['password'] != self.password:
            return {'code': http.client.FORBIDDEN}

        accepted = ['movx', 'movy', 'comx', 'comy']
        self.update({k: v for k, v in data.items() if k in accepted})

        return {'code': http.client.ACCEPTED}

    # Atualiza dados e dispara notificação caso haja mudanças.
    def update(self, data):
        changes = False
        for i, j in data.items():
            if i not in self.attributes or j != self.attributes[i]:
                changes = True
        self.attributes.update(data)
        if changes:
            self.notify()

    # Método que trata colisão com outro jogador.
    def collide(self, player):
        self.update({'movx': 0, 'movy': 0})


# Main.
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Servidor do jogo.',
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-p', '--port', type=int, default=8000,
            help='A porta para hospedar o servidor.')
    parser.add_argument('-s', '--step', type=float, default=0.2,
            help='O intervalo de tempo em segundos entre atualizações.')
    args = parser.parse_args()

    server = Server('localhost', args.port)
    game = Game(args.step)
    server.root.add_child('game', game)

    game.start()
    server.serve_forever()


