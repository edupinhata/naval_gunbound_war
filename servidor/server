#!/usr/bin/env python3

import socketserver
import http.server
import threading
import hashlib
import json
import time
import sys
import os

class Server(socketserver.ThreadingMixIn, http.server.HTTPServer):

    def __init__(self, address, port):
        http.server.HTTPServer.__init__(self, (address, port), Handler)
        self.resources = {}

    def add_resource(self, resource):
        self.resources[resource.path] = resource

    def remove_resource(self, path):
        if path in self.resources:
            del self.resources[path]

    def get_resource(self, path):
        return self.resources[path] if path in self.resources else Resource()

    def get_resources(self, path):
        return [self.resources[x] for x in self.resources if path in x]


class Handler(http.server.BaseHTTPRequestHandler):

    def do_GET(self):
        self.server.get_resource(self.path).do_GET(self)

    def do_POST(self):
        self.server.get_resource(self.path).do_POST(self)

    def do_PUT(self):
        self.server.get_resource(self.path).do_PUT(self)

    def do_DELETE(self):
        self.server.get_resource(self.path).do_DELETE(self)

    def read(self):
        try:
            length = int(self.headers['Content-Length'])
            string = self.rfile.read(length).decode('utf-8')
            return json.loads(string)
        except:
            return {}

    def reply(self, code=200, data=None, headers=[]):
        try:
            self.send_response(code)
            for h in headers:
                self.send_header(h[0], h[1])
            self.end_headers()
            if data:
                self.wfile.write(bytes(json.dumps(data), 'utf-8'))
        except:
            pass


class Resource(object):

    def __init__(self, path, server, default_reply=405):
        self.path = path
        self.server = server
        self.server.add_resource(self)
        self.default_reply = default_reply

    def do_GET(self, handler):
        handler.reply(self.default_reply)

    def do_POST(self, handler):
        handler.reply(self.default_reply)

    def do_PUT(self, handler):
        handler.reply(self.default_reply)

    def do_DELETE(self, handler):
        handler.reply(self.default_reply)


class Notifier(Resource):

    def __init__(self, path, server):
        Resource.__init__(self, path, server)
        self.listeners = {}

    def do_GET(self, handler):
        self.listeners[handler] = threading.Event()
        self.listeners[handler].wait()

    def notify(self, notification=None):
        listeners = self.listeners
        self.listeners = {}
        for handler, event in listeners.items():
            handler.reply(data=notification)
            event.set()


class Game(Notifier):

    def __init__(self, path, server):
        Notifier.__init__(self, path, server)
        self.players = {}
        self.board = {}

    def do_POST(self, handler):
        data = handler.read()
        path = self.path + '/' + self.get_token()

        player = Player(self, path, data)

        handler.server.add_resource(player)
        handler.reply(201, headers=[('Location', player.path)])

    def get_token(self):
        h = hashlib.md5()
        h.update(os.urandom(4096))
        return h.hexdigest()

    def get_players(self):
        return self.server.get_resources(self.path + '/')


class Player(Resource):

    def __init__(self, game, path, data):
        Resource.__init__(self, path, game.server)
        self.game = game
        self.attributes = {'name': data['name'] if 'name' in data else '',
                           'hp': 10,
                           'position': {'x': 0, 'y': 0},
                           'movement': {'x': 0, 'y': 0},
                           'combat': {'x': 0, 'y': 0},
                           'delete': False}
        self.game.notify(self.attributes)

    def do_GET(self, handler):
        handler.reply(data=self.attributes)

    def do_PUT(self, handler):
        data = handler.read()
        for field in ['movement', 'combat']:
            if field in data:
                self.attributes[field].update(data[field])

        self.game.notify(self.attributes)
        handler.reply(202)

    def do_DELETE(self, handler):
        self.die()
        handler.reply(204)

    def update(self):
        current = self.attributes['position']
        delta = self.attributes['movement']
        future = {k: current[k] + delta[k] for k in current}
        if current == future:
            return

        self.attributes['position'] = future
        self.game.notify(self.attributes)

    def die(self):
        self.attributes['delete'] = True
        self.game.notify(self.attributes)
        self.server.remove_resource(self.path)


class Worker(threading.Thread):

    def __init__(self, game, step):
        threading.Thread.__init__(self)
        self.game = game
        self.step = step

    def run(self):
        while True:
            time.sleep(self.step)
            for p in game.get_players():
                p.update()


if __name__ == '__main__':
    server = Server('localhost', int(sys.argv[1]) if len(sys.argv) > 1 else 80)

    game = Game('/game', server)

    worker = Worker(game, 0.25)
    worker.start()

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.socket.close()

