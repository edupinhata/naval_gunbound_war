#!/usr/bin/env python3

import socketserver
import http.server
import http.client
import email.utils
import threading
import hashlib
import json
import time
import sys
import os


class Server(socketserver.ThreadingMixIn, http.server.HTTPServer):

    def __init__(self, address, port):
        socketserver.ThreadingMixIn.__init__(self)
        http.server.HTTPServer.__init__(self, (address, port), Handler)
        self.root = Resource()
        self.not_found = Resource({'code': http.client.NOT_FOUND})

    def find_resource(self, path):
        path_list = path.split('/')
        path_list.pop(0)

        res = self.root
        for child in path_list:
            if child not in res.children:
                return self.not_found
            res = res.children[child]

        return res


class Handler(http.server.BaseHTTPRequestHandler):

    def do_GET(self):
        self.reply(self.server.find_resource(self.path).do_GET(self.read()))

    def do_POST(self):
        self.reply(self.server.find_resource(self.path).do_POST(self.read()))

    def do_PUT(self):
        self.reply(self.server.find_resource(self.path).do_PUT(self.read()))

    def read(self):
        data = {'timestamp': self.get_timestamp()}
        try:
            length = int(self.headers['Content-Length'])
            string = self.rfile.read(length).decode('utf-8')
            data.update(json.loads(string))
        except:
            pass
        finally:
            return data

    def reply(self, args={}):
        try:
            response = {'code': http.client.OK,
                        'data': None,
                        'headers': []}
            response.update(args)

            self.send_response(response['code'])

            for h in response['headers']:
                self.send_header(h[0], h[1])
            self.end_headers()

            if response['data']:
                self.wfile.write(bytes(json.dumps(response['data']), 'utf-8'))
        except:
            pass

    def get_timestamp(self):
        field = 'If-Modified-Since'
        if field not in self.headers:
            return time.mktime(time.gmtime(0))
        return time.mktime(email.utils.parsedate((self.headers[field])))


class Resource(object):

    def __init__(self, default_reply={'code': http.client.METHOD_NOT_ALLOWED}):
        self.default_reply = default_reply

        self.path = ''
        self.children = {}
        self.delete_event = threading.Event()

    def do_GET(self, data):
        return self.default_reply

    def do_POST(self, data):
        return self.default_reply

    def do_PUT(self, data):
        return self.default_reply

    def add_child(self, path, resource):
        self.children[path] = resource
        threading.Thread(target=self.wait_for_delete,
                kwargs={'path': path}).start()

    def wait_for_delete(self, path):
        resource = self.children[path]
        resource.delete_event.wait()
        del self.children[path]


class Monitor(Resource):

    def __init__(self):
        Resource.__init__(self)
        self.timestamp = time.time()
        self.update_event = threading.Event()

    def do_GET(self, data):
        t = 'timestamp'
        if t in data and data[t] > self.timestamp:
            self.update_event.wait()
        return {'data': self.get_data(),
                'headers': [('Last-Modified',
                             email.utils.formatdate(self.timestamp))]}

    def notify(self):
        self.update_event.set()
        self.update_event.clear()

    def get_data(self):
        return None


class Container(Monitor):

    def get_data(self):
        children = self.children.copy()
        return [path for path in children.keys()]

    def add_child(self, path, resource):
        Resource.add_child(self, path, resource)
        self.notify()

    def wait_for_delete(self, path):
        Resource.wait_for_delete(self, path)
        self.notify()


class Game(Container):

    def do_POST(self, data):
        if 'timestamp' in data:
            del data['timestamp']

        if 'password' not in data:
            return {'code': http.client.EXPECTATION_FAILED,
                    'headers': [('Accept', 'application/json')]}

        password = data['password']
        del data['password']

        p = Player(data, password)

        token = self.get_token()
        self.add_child(token, p)

        self.notify()
        return {'code': http.client.CREATED,
                'headers': [('Location', token)]}

    def get_token(self):
        h = hashlib.md5()
        h.update(os.urandom(4096))
        return h.hexdigest()

    def run(self):
        while True:
            time.sleep(self.step)
            for p in game.children.values():
                p.update({})
                # TODO lÃ³gica do jogo aqui


class Player(Monitor):

    def __init__(self, data, password):
        Monitor.__init__(self)
        self.password = password
        self.attributes = data
        self.attributes.update({
            'hp': 10,
            'kills': 0,
            'position': {'x': 0, 'y': 0},
            'movement': {'x': 0, 'y': 0},
            'combat': {'x': 0, 'y': 0},
            })

    def get_data(self):
        return self.attributes

    def do_PUT(self, data):
        if 'password' not in data:
            return {'code': http.client.EXPECTATION_FAILED}
        if data['password'] != self.password:
            return {'code': http.client.FORBIDDEN}

        for field in ['movement', 'combat']:
            if field in data:
                self.attributes[field].update(data[field])

        self.notify()
        return {'code': http.client.ACCEPTED}


if __name__ == '__main__':
    server = Server('localhost', int(sys.argv[1]) if len(sys.argv) > 1 else 80)

    game = Game()
    server.root.add_child('game', game)

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.socket.close()

