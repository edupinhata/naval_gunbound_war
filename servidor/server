#!/usr/bin/env python3

import socketserver
import http.server
import threading
import hashlib
import json
import time
import sys
import os


class Server(socketserver.ThreadingMixIn, http.server.HTTPServer):

    def __init__(self, address, port):
        http.server.HTTPServer.__init__(self, (address, port), Handler)
        self.root = Resource()
        self.not_found = Resource({'code': 404})

    def find_resource(self, path):
        path_list = path.split('/')
        path_list.pop(0)

        res = self.root
        for child in path_list:
            if child not in res.children:
                return self.not_found
            res = res.children[child]

        return res


class Handler(http.server.BaseHTTPRequestHandler):

    def do_GET(self):
        self.reply(self.server.find_resource(self.path).do_GET(self.read()))

    def do_POST(self):
        self.reply(self.server.find_resource(self.path).do_POST(self.read()))

    def do_PUT(self):
        self.reply(self.server.find_resource(self.path).do_PUT(self.read()))

    def do_DELETE(self):
        self.reply(self.server.find_resource(self.path).do_DELETE(self.read()))

    def read(self):
        try:
            length = int(self.headers['Content-Length'])
            string = self.rfile.read(length).decode('utf-8')

            return json.loads(string)
        except:
            return {}

    def reply(self, args={}):
        try:
            response = {'code': 200, 'headers': [], 'data': None}
            response.update(args)

            self.send_response(response['code'])

            for h in response['headers']:
                self.send_header(h[0], h[1])
            self.end_headers()

            if response['data']:
                self.wfile.write(bytes(json.dumps(response['data']), 'utf-8'))
        except:
            pass


class Resource(object):

    def __init__(self, default_reply={'code': 405}):
        self.default_reply = default_reply

        self.path = ''
        self.children = {}
        self.delete_event = threading.Event() # TODO suportar múltiplos ouvintes

    def do_GET(self, data):
        return self.default_reply

    def do_POST(self, data):
        return self.default_reply

    def do_PUT(self, data):
        return self.default_reply

    def do_DELETE(self, data):
        return self.default_reply

    def add_child(self, path, resource):
        self.children[path] = resource
        resource.path = self.path + '/' + path

        threading.Thread(target=self.wait_delete,
                kwargs={'path': path}).start()

    def wait_delete(self, path):
        resource = self.children[path]
        resource.delete_event.wait()
        del self.children[path]


class Notifier(Resource):

    def __init__(self):
        Resource.__init__(self)
        self.listeners = []

    def do_GET(self, data):
        request = {'event': threading.Event(), 'reply':{}}

        self.listeners += [request]
        request['event'].wait()

        return {'code': 200, 'data': request['reply']}

    def notify(self, data={}):
        listeners = self.listeners
        self.listeners = []

        for request in listeners:
            request['reply'] = data
            request['event'].set()


class Game(Notifier, threading.Thread):

    def __init__(self, step):
        Notifier.__init__(self)
        threading.Thread.__init__(self)
        self.step = step

    def do_POST(self, data):
        if 'name' not in data:
            return {'code': 403} # TODO achar código melhor

        p = Player(data)
        self.add_child(self.get_token(), p)
        p.update_event.set()

        return {'code': 201, 'headers': [('Location', p.path)]}

    def get_token(self):
        h = hashlib.md5()
        h.update(os.urandom(4096))
        return h.hexdigest()

    def add_child(self, path, resource):
        Resource.add_child(self, path, resource)
        threading.Thread(target=self.wait_update,
                kwargs={'path': path}).start()

    def wait_update(self, path):
        player = self.children[path]
        while True:
            player.update_event.wait()
            player.update_event.clear()
            self.notify(player.attributes)

    def run(self):
        while True:
            time.sleep(self.step)
            for p in game.children.values():
                pass # TODO lógica do jogo aqui


class Player(Resource):

    def __init__(self, data):
        Resource.__init__(self)
        self.update_event = threading.Event()
        self.attributes = {'name': data['name'],
                           'hp': 10,
                           'position': {'x': 0, 'y': 0},
                           'movement': {'x': 0, 'y': 0},
                           'combat': {'x': 0, 'y': 0},
                           'delete': False}

    def do_GET(self, data):
        return {'code': 200, 'data': self.attributes}

    def do_PUT(self, data):
        # TODO validar dados
        for field in ['movement', 'combat']:
            if field in data:
                self.attributes[field].update(data[field])
        self.update_event.set()

        return {'code': 202}

    def do_DELETE(self, data):
        self.die()
        return {'code': 204}

    def update(self, data):
        pass # TODO

    def die(self):
        self.attributes['delete'] = True
        self.update_event.set()
        self.delete_event.set()


if __name__ == '__main__':
    server = Server('localhost', int(sys.argv[1]) if len(sys.argv) > 1 else 80)

    game = Game(0.25)
    server.root.add_child('game', game)
    game.start()

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.socket.close()

